using System;
using System.Linq;
using FullTextIndexer.Common.Lists;
using FullTextIndexer.Core.Indexes.TernarySearchTree;
using FullTextIndexer.Core.TokenBreaking;
using FullTextIndexer.Helpers;
using FullTextIndexer.Querier;
using Xunit;

namespace UnitTests.Querier
{
	/// <summary>
	/// These are more like integration tests considering how much code they're really executing - but they work as documentation
	/// as well as functional testing
	/// </summary>
	public static class QuerierTests
	{
		[Fact]
		public static void SingleTerm()
		{
			var matchesFor_Generator = GetQuerier(TestData).GetMatches("Generator");
			Assert.Equal(1, matchesFor_Generator.Count);
			Assert.Equal(31, matchesFor_Generator[0].Key);
			Assert.Equal(2, matchesFor_Generator[0].Weight);
		}

		/// <summary>
		/// When two terms are specified, they are interpreted as an OR query - an AND query would have the terms wrapped in
		/// CompulsoryQuerySegment instances (which would be generated by prefixing each term with a plus sign)
		/// </summary>
		[Fact]
		public static void TwoSimpleTerms()
		{
			var matchesFor_Generator = GetQuerier(TestData).GetMatches("wholeheartedly pushing");
			Assert.Equal(2, matchesFor_Generator.Count);
			Assert.Equal(30, matchesFor_Generator[0].Key);
			Assert.Equal(1, matchesFor_Generator[0].Weight);
			Assert.Equal(32, matchesFor_Generator[1].Key);
			Assert.Equal(1, matchesFor_Generator[1].Weight);
		}

		[Fact]
		public static void TwoCompulsorySimpleTerms()
		{
			var matchesFor_Generator = GetQuerier(TestData).GetMatches("+Adding +TSource");
			Assert.Equal(1, matchesFor_Generator.Count);
			Assert.Equal(31, matchesFor_Generator[0].Key);
			Assert.Equal(3, matchesFor_Generator[0].Weight); // The match weight is three since "Adding" appears once and "TSource" appears twice
		}

		private static NonNullImmutableList<Post> TestData => new NonNullImmutableList<Post>(new[]
		{
			new Post(30, "The Full Text Indexer", "I started out on a journey a few months ago being " +
				"frustrated by the Lucene.net integration we had with one of our products at work (I'm not " +
				"badmouthing the Lucene project, I'm wholeheartedly blaming the integration I inherited!)"),
			new Post(31, "The Full Text Indexer - Adding and Subtracting", "The Full Text Indexer that I " +
				"talked about last time took a definition for an Index Generator for a specific TSource type " +
				"and produced an IndexData instance, using that generator, for a TSource set."),
			new Post(32, "The Full Text Indexer - Going International!", "Pushing on with the Full Text " +
				"Indexer series I'm been posting about (see Full Text Indexer and Full Text Indexer - Adding " +
				"and Subtracting) I want to demonstrate how it can work with multi-lingual content")
		});

		private static Querier<int> GetQuerier(NonNullImmutableList<Post> posts)
		{
			var defaultIndexGenerator = (new AutomatedIndexGeneratorFactoryBuilder<Post, int>()).Get().Get();
			var preciseMatchIndexGenerator = (new AutomatedIndexGeneratorFactoryBuilder<Post, int>())
				.SetTokenBreaker(
					new ConsecutiveTokenCombiningTokenBreaker(
						// The ConsecutiveTokenCombiningTokenBreaker wraps another token breaker and then creates new
						// tokens by stringing runs of broken tokens together
						new WhiteSpaceExtendingTokenBreaker(
							new ImmutableList<char>(new[] { '<', '>', '[', ']', '(', ')', '{', '}', '.', ',' }),
							new WhiteSpaceTokenBreaker()
						),

						// This is the maximum number of words that are strung together, if quoted sections have more
						// words than this then they won't be matched. A way to work around this may be hashed out
						// one day (but not today :)
						12,

						// Tokens may be given an additional weight multiplier (between 0 and 1) when content is
						// is broken down, when multiple tokens are combined a multiplier for the combined token
						// must be provider. Commonly it is stop words that have a fractional multiplier, but
						// when words are combined into a phrase, it makes sense to remove any fractional
						// multiplier and give the combined token the full value of 1.
						weightMultipliersOfCombinedTokens => 1
					)
				)
				.SetStringNormaliser(DefaultStringNormaliser.Instance)
				.Get()
				.Get();

			return new Querier<int>(
				defaultIndexGenerator.Generate(posts),
				preciseMatchIndexGenerator.Generate(posts),
				(matchWeights, sourceQuerySegments) => matchWeights.Sum()
			);
		}

		private sealed class Post
		{
			public Post(int id, string title, string content)
			{
				if (string.IsNullOrWhiteSpace(title))
					throw new ArgumentException("Null/blank title specified");
				if (string.IsNullOrWhiteSpace(content))
					throw new ArgumentException("Null/blank content specified");

				Id = id;
				Title = title;
				Content = content;
			}

			public int Id { get; set; }
			public string Title { get; set; }
			public string Content { get; set; }
		}
	}
}
